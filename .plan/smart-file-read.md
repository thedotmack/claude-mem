# Smart File Read Integration Plan

Integrate Smart File Read (tree-sitter AST code search) as 3 new MCP tools in the claude-mem plugin, exposed via a `smart-explore` skill.

## Phase 0: Discovery Summary

### Architecture Findings

**MCP Server** (`src/servers/mcp-server.ts`):
- Tools defined as objects: `{ name, description, inputSchema, handler }`
- Two handler patterns: `callWorkerAPI()` (GET) and `callWorkerAPIPost()` (POST)
- Registered via `setRequestHandler` for `ListToolsRequestSchema` / `CallToolRequestSchema`
- Currently 5 tools: `__IMPORTANT`, `search`, `timeline`, `get_observations`, `save_observation`
- Built with esbuild to `plugin/scripts/mcp-server.cjs` (342 KB, CJS, node18 target)
- Only external: `bun:sqlite`

**Skill Structure** (`plugin/skills/<name>/SKILL.md`):
- YAML frontmatter: `name`, `description`
- Markdown body: workflow, parameters, examples
- References MCP tools by name directly in prose
- No programmatic connection — Claude reads the SKILL.md and recognizes tool names
- Skills auto-discovered from `plugin/skills/` directory

**Build** (`scripts/build-hooks.js`):
- esbuild bundles all source into single CJS files
- Native modules must be externalized (can't be bundled by esbuild)
- Runtime deps go in `plugin/package.json` (generated by build script at line 55-70) and installed via `smart-install.js` using `bun install`
- `@chroma-core/default-embed` in `plugin/package.json` is unused (Chroma uses MCP subprocess now) — will be replaced by tree-sitter WASM deps

### Key Architectural Decision: Direct Execution vs HTTP Delegation

Current tools delegate to the Worker HTTP API. Smart File Read is different:
- Read-only file I/O + AST parsing — no database, no state
- Sub-second response times — HTTP round-trip adds latency for no benefit
- No worker dependency — works independently of the memory system

**Decision: Direct execution in MCP server.** The 3 smart_* tool handlers call parser/search functions directly, not via HTTP. This keeps the tools fast and independent of worker availability.

### Cross-Platform Dependency Strategy: WASM (Replacing Native)

The original plan used native tree-sitter (10 packages requiring C++ compilation via node-gyp). This was validated as broken for cross-platform distribution:

**Problems with native approach:**
- tree-sitter v0.25.0 was not on npm; v0.22.4 lacks Node 24 C++20 fix
- ALL 10 packages (core + 9 grammars) require node-gyp native compilation
- End users need C++ toolchain, Python, and platform-specific build tools
- Windows users need Visual Studio Build Tools
- `--legacy-peer-deps` required due to conflicting peer dep ranges
- `file:_tree-sitter` vendored build only works for local development

**WASM solution (validated):**
- **Runtime**: `web-tree-sitter` (v0.26.5) — pure JS + WASM, zero native compilation
  - Ships `web-tree-sitter.cjs` (CJS) + `web-tree-sitter.wasm` (196 KB)
  - CJS `require('web-tree-sitter')` exports `{ Parser, Language, ... }`
  - `Parser.init()` auto-locates its `.wasm` via `__dirname` when loaded from node_modules
  - `Language.load(filePath)` accepts filesystem path, uses `fs/promises.readFile` in Node.js
- **Grammar WASM files**: `tree-sitter-wasms` (v0.1.13) — 36 pre-built `.wasm` grammars
  - Files at `node_modules/tree-sitter-wasms/out/tree-sitter-<lang>.wasm`
  - Covers all 9 languages: javascript, typescript, tsx, python, go, rust, ruby, java, c, cpp
  - No compilation, no node-gyp, no platform-specific binaries
- **Cross-platform**: Works on macOS, Linux, Windows, any Node.js version, any arch
- **No `--legacy-peer-deps`**: web-tree-sitter and tree-sitter-wasms have no conflicting peers
- **Performance**: WASM is slower than native (~4x) but still sub-100ms per file parse — irrelevant for MCP tool calls

### Parser Migration Scope (Validated)

Changing `parser.ts` from native to WASM affects ~50 lines out of 809:

| Change | Lines | Difficulty |
|---|---|---|
| Imports (remove native, add web-tree-sitter) | ~5 | Trivial |
| `loadGrammar()` rewrite (sync require → async Language.load) | ~30 | Easy |
| `parseFile()` → async (add await for loadGrammar) | ~3 | Trivial |
| `unfoldSymbol()` → async (add await for parseFile) | ~2 | Trivial |
| `Parser.init()` one-time initialization | ~8 | Easy |
| **SyntaxNode traversal code (700+ lines)** | **0** | **None** |

Key API compatibility: `node.type`, `node.text`, `node.children`, `node.namedChildren`, `node.childForFieldName()`, `node.startPosition.row`, `node.endPosition.row`, `node.parent`, `tree.rootNode` — all identical between native and WASM.

Type difference: native exports `SyntaxNode`, WASM exports `Parser.SyntaxNode` (alias with `type SyntaxNode = Parser.SyntaxNode`).

### Downstream Impact of Async

- `search.ts` line 147: `parseFile()` call inside `searchCodebase()` — `searchCodebase()` is already async, just add `await`
- MCP tool handlers in `mcp-server.ts` — MCP handlers are already async, just add `await`
- `formatSearchResults()` and `formatFoldedView()` — unchanged (operate on parsed results, not parsers)

### Source Status

Source files already copied into worktree at `smart-file-read/`:
- `parser.ts` (809 lines) — AST parsing, code folding, language extractors
- `search.ts` (315 lines) — directory walker, fuzzy matching, formatting
- `index.ts` — standalone MCP server (reference only, not ported)
- `_tree-sitter/` — vendored node-tree-sitter v0.25.1 (no longer needed for integration — WASM replaces this)

### Test Results (Validated)

See `smart-file-read/PRELIMINARY-RESULTS.md` for full test matrix. Key findings:
- smart_search: 6-12x token savings vs Explore agent for cross-cutting concerns
- smart_outline: 8x token reduction vs reading full files
- smart_unfold: targeted extraction at ~1.6k tokens vs ~12k for full file
- Python support verified (functions + imports extracted correctly)

---

## Phase 1: Source Integration + WASM Migration

**Goal**: Port Smart File Read's core logic into the claude-mem source tree, adapted for web-tree-sitter WASM.

### Tasks

1. Create `src/services/smart-file-read/` directory

2. Copy `parser.ts` from `smart-file-read/parser.ts` and apply WASM migration:

   **a. Replace imports** (lines 13-17):
   ```typescript
   // BEFORE:
   import Parser from "tree-sitter";
   import type { SyntaxNode } from "tree-sitter";
   import { createRequire } from "node:module";
   const require = createRequire(import.meta.url);

   // AFTER:
   import TreeSitter from "web-tree-sitter";
   type SyntaxNode = TreeSitter.SyntaxNode;
   import { join, dirname } from "node:path";
   import { createRequire } from "node:module";
   const require = createRequire(import.meta.url);
   ```

   **b. Add initialization guard** (new, before loadGrammar):
   ```typescript
   let initialized = false;
   async function ensureInitialized(): Promise<void> {
     if (initialized) return;
     await TreeSitter.init();
     initialized = true;
   }
   ```

   **c. Rewrite `loadGrammar()`** (lines 23-67) — sync `require()` → async `Language.load()`:
   ```typescript
   const WASM_GRAMMAR_FILES: Record<string, string> = {
     javascript: "tree-sitter-javascript.wasm",
     typescript: "tree-sitter-typescript.wasm",
     tsx: "tree-sitter-tsx.wasm",
     python: "tree-sitter-python.wasm",
     go: "tree-sitter-go.wasm",
     rust: "tree-sitter-rust.wasm",
     ruby: "tree-sitter-ruby.wasm",
     java: "tree-sitter-java.wasm",
     c: "tree-sitter-c.wasm",
     cpp: "tree-sitter-cpp.wasm",
   };

   const grammarCache = new Map<string, TreeSitter.Language>();

   function getWasmDirectory(): string {
     return join(dirname(require.resolve('tree-sitter-wasms/package.json')), 'out');
   }

   async function loadGrammar(language: string): Promise<TreeSitter.Language | null> {
     if (grammarCache.has(language)) return grammarCache.get(language)!;
     const wasmFile = WASM_GRAMMAR_FILES[language];
     if (!wasmFile) return null;
     try {
       const wasmPath = join(getWasmDirectory(), wasmFile);
       const lang = await TreeSitter.Language.load(wasmPath);
       grammarCache.set(language, lang);
       return lang;
     } catch {
       return null;
     }
   }
   ```

   **d. Make `parseFile()` async** (line 646):
   ```typescript
   // BEFORE:
   export function parseFile(content: string, filePath: string): FoldedFile {
     const language = detectLanguage(filePath);
     const grammar = loadGrammar(language);

   // AFTER:
   export async function parseFile(content: string, filePath: string): Promise<FoldedFile> {
     await ensureInitialized();
     const language = detectLanguage(filePath);
     const grammar = await loadGrammar(language);
   ```
   Also add null check after `parser.parse()`:
   ```typescript
   const tree = parser.parse(content);
   if (!tree) {
     return { filePath, language, symbols: [], imports: [], totalLines: lines.length, foldedTokenEstimate: 50 };
   }
   ```

   **e. Make `unfoldSymbol()` async** (line 773):
   ```typescript
   // BEFORE:
   export function unfoldSymbol(content: string, filePath: string, symbolName: string): string | null {
     const file = parseFile(content, filePath);

   // AFTER:
   export async function unfoldSymbol(content: string, filePath: string, symbolName: string): Promise<string | null> {
     const file = await parseFile(content, filePath);
   ```

   **f. Keep everything else unchanged**:
   - All `SyntaxNode` traversal code (700+ lines) — identical API
   - All language-specific extractors (`extractJSTSSymbols`, `extractPythonSymbols`, etc.)
   - `formatFoldedView()`, `formatSymbol()`, `getSymbolIcon()`
   - `detectLanguage()`, `LANG_MAP`
   - All types: `CodeSymbol`, `FoldedFile`, `ExtractContext`

3. Copy `search.ts` from `smart-file-read/search.ts`:
   - Keep all exports: `searchCodebase`, `formatSearchResults`, `SearchResult`, `SymbolMatch`
   - Update line 147: `const parsed = parseFile(content, relPath)` → `const parsed = await parseFile(content, relPath)`
   - `searchCodebase()` is already async — no signature change needed

### Documentation References
- Source parser.ts: lines 13-17 (imports), 23-67 (loadGrammar), 646-698 (parseFile), 773-808 (unfoldSymbol)
- Source search.ts: line 117 (searchCodebase signature), line 147 (parseFile call)
- web-tree-sitter CJS: `require('web-tree-sitter')` → `{ Parser, Language }`
- web-tree-sitter init: `await Parser.init()` — auto-locates `.wasm` via `__dirname` in CJS
- Language.load: `await Language.load(absoluteFilePath)` — uses `fs/promises.readFile` in Node.js
- tree-sitter-wasms: `.wasm` files at `node_modules/tree-sitter-wasms/out/tree-sitter-<lang>.wasm`

### Anti-Pattern Guards
- Do NOT use `locateFile` override in `Parser.init()` — not needed when web-tree-sitter is loaded from node_modules (its `__dirname` resolves correctly)
- Do NOT import `Parser.Node` — alias as `SyntaxNode` to minimize churn in the 700+ lines of traversal code
- Do NOT make `formatFoldedView` or `formatSearchResults` async — they don't touch the parser

### Verification
- [ ] `src/services/smart-file-read/parser.ts` exists with async `parseFile` and `unfoldSymbol`
- [ ] `src/services/smart-file-read/search.ts` exists with `await parseFile` at line 147
- [ ] No references to native `tree-sitter` package (should only reference `web-tree-sitter`)
- [ ] No `createRequire` usage for grammar loading (only for `require.resolve` of tree-sitter-wasms path)
- [ ] All SyntaxNode traversal code unchanged from source

---

## Phase 2: MCP Tool Registration

**Goal**: Register `smart_search`, `smart_unfold`, and `smart_outline` as MCP tools on the existing claude-mem server.

### Tasks

1. Add imports to `src/servers/mcp-server.ts`:
   ```typescript
   import { searchCodebase, formatSearchResults } from '../services/smart-file-read/search.js';
   import { parseFile, formatFoldedView, unfoldSymbol } from '../services/smart-file-read/parser.js';
   ```
   Also add: `import { readFile } from 'node:fs/promises';` and `import { resolve, relative } from 'node:path';`

2. Add 3 tool definitions to the `tools` array (after existing tools, before server registration):

   **smart_search** — handler calls `searchCodebase()` + `formatSearchResults()` directly
   - inputSchema: `query` (string, required), `path` (string, default "."), `max_results` (number, default 20), `file_pattern` (string, optional)
   - Handler resolves `path`, calls `await searchCodebase(rootDir, query, options)`, formats results

   **smart_unfold** — handler calls `unfoldSymbol()` directly
   - inputSchema: `file_path` (string, required), `symbol_name` (string, required), `path` (string, default ".")
   - Handler reads file, calls `await unfoldSymbol(content, filePath, symbolName)`
   - On miss: calls `await parseFile()` and lists available symbols

   **smart_outline** — handler calls `parseFile()` + `formatFoldedView()` directly
   - inputSchema: `file_path` (string, required), `path` (string, default ".")
   - Handler reads file, calls `await parseFile()`, returns `formatFoldedView()`

3. All handlers return MCP-format responses: `{ content: [{ type: 'text', text: string }], isError?: boolean }`

### Pattern to Follow
- Match existing tool definition style in `mcp-server.ts` lines 157-262
- Use JSON Schema (not Zod) for inputSchema — the existing MCP server uses raw JSON Schema
- snake_case tool names: `smart_search`, `smart_unfold`, `smart_outline`
- Add `readOnlyHint: true` annotation metadata (these tools are read-only)

### Anti-Pattern Guards
- Do NOT add these tools to `TOOL_ENDPOINT_MAP` — they don't use HTTP delegation
- Do NOT add worker API endpoints — direct execution only
- Do NOT use Zod for schemas — existing tools use raw JSON Schema objects

### Verification
- [ ] 3 new tools appear in `ListToolsRequestSchema` response
- [ ] `smart_search` returns folded views when called
- [ ] `smart_unfold` returns full source of a specific symbol
- [ ] `smart_outline` returns structural outline of a file
- [ ] Tools degrade gracefully when tree-sitter grammars aren't available

---

## Phase 3: Build System Updates

**Goal**: Configure esbuild externals and runtime dependencies for WASM-based tree-sitter.

### Tasks

1. Add to root `package.json` devDependencies (for local development/type-checking):
   ```json
   "web-tree-sitter": "^0.26.5",
   "tree-sitter-wasms": "^0.1.13"
   ```
   Then run `npm install`.

2. Update `scripts/build-hooks.js` plugin package.json generation (lines 55-70) — replace `@chroma-core/default-embed` with WASM deps:
   ```javascript
   dependencies: {
     'web-tree-sitter': '^0.26.5',
     'tree-sitter-wasms': '^0.1.13',
   }
   ```

3. Update `scripts/build-hooks.js` MCP server build (~line 131) — add WASM packages to externals:
   ```javascript
   external: [
     'bun:sqlite',
     'web-tree-sitter',
     'tree-sitter-wasms',
   ],
   ```
   These must be externalized because:
   - `web-tree-sitter` loads `web-tree-sitter.wasm` from its own `__dirname` at runtime
   - `tree-sitter-wasms` `.wasm` files must be resolvable via `require.resolve` from node_modules

4. Remove unused Chroma externals from the worker service build (lines 100-105): `@chroma-core/default-embed`, `onnxruntime-node`, `cohere-ai`, `ollama` — Chroma now uses its own MCP subprocess.

### Why This Works at Runtime

The bundled `plugin/scripts/mcp-server.cjs` contains:
- `require("web-tree-sitter")` — resolved from `plugin/node_modules/web-tree-sitter/web-tree-sitter.cjs`
  - Inside this CJS module, `__dirname` points to `plugin/node_modules/web-tree-sitter/`
  - `Parser.init()` auto-finds `web-tree-sitter.wasm` at that `__dirname` — no `locateFile` needed
- `require.resolve("tree-sitter-wasms/package.json")` — resolved from `plugin/node_modules/tree-sitter-wasms/`
  - Grammar `.wasm` files at `plugin/node_modules/tree-sitter-wasms/out/tree-sitter-<lang>.wasm`

`bun install` (via `smart-install.js`) installs both packages in `plugin/node_modules/`. No native compilation. No node-gyp. No C++ toolchain. Works on any platform.

### Verification
- [ ] `npm run build` succeeds
- [ ] `plugin/scripts/mcp-server.cjs` contains `require("web-tree-sitter")` (externalized, not bundled)
- [ ] `plugin/scripts/mcp-server.cjs` does NOT contain `require("tree-sitter")` (native package removed)
- [ ] `plugin/package.json` includes `web-tree-sitter` and `tree-sitter-wasms` (generated by build script)
- [ ] `bun install` in plugin/ directory installs both packages with zero native compilation

---

## Phase 4: Skill Creation

**Goal**: Create `plugin/skills/smart-explore/SKILL.md` following the mem-search pattern.

### Tasks

1. Create `plugin/skills/smart-explore/SKILL.md` using the validated content from `smart-file-read/PRELIMINARY-RESULTS.md` Part 2 as the primary source. Structure:

   **Frontmatter**:
   ```yaml
   ---
   name: smart-explore
   description: Token-optimized structural code search using tree-sitter AST parsing. Use instead of reading full files when you need to understand code structure, find functions, or explore a codebase efficiently.
   ---
   ```

   **Content** (from validated PRELIMINARY-RESULTS Part 2):
   - `# Smart Explore` — title
   - 3-layer progressive disclosure workflow (search → outline → unfold)
   - Tool parameters for all 3 tools (validated schemas from index.ts)
   - When to use / when NOT to use (validated from test results)
   - Examples showing real usage patterns (validated from test runs)
   - Token economics summary (validated numbers from test matrix)

### Pattern to Follow
- `plugin/skills/mem-search/SKILL.md` for structure and tone
- Reference tools by name: `smart_search`, `smart_unfold`, `smart_outline`
- Show parameter usage in code blocks
- Include token savings rationale

### Anti-Pattern Guards
- Do NOT add operations subdirectory — not needed (mem-search's is legacy)
- Do NOT reference HTTP endpoints — skill consumers use MCP tools, not HTTP

### Verification
- [ ] `plugin/skills/smart-explore/SKILL.md` exists with valid YAML frontmatter
- [ ] All 3 tools documented with parameters
- [ ] Progressive disclosure workflow clearly described
- [ ] Examples show real usage patterns

---

## Phase 5: Plugin Manifest & Registration

**Goal**: Register the new skill in the plugin manifest so Claude Code discovers it.

### Tasks

1. Check `plugin/.claude-plugin/plugin.json` — if it has a `skills` array, add `"skills/smart-explore"`. If skills are auto-discovered from `plugin/skills/` (current behavior), no manifest changes needed.
2. The MCP tools are automatically exposed (they're on the same `mcp-search` MCP server defined in `.mcp.json` — no changes needed there)

### Verification
- [ ] Skill appears in Claude Code's `/skills` listing
- [ ] MCP tools appear alongside existing claude-mem tools

---

## Phase 6: Build, Test & Verify

**Goal**: End-to-end verification.

### Tasks

1. `npm install` — install web-tree-sitter + tree-sitter-wasms (no special flags needed)
2. `npm run build` — verify clean build
3. `npm run build-and-sync` — deploy to local plugin directory
4. Start a new Claude Code session and verify:
   - `smart_search` tool is available via MCP
   - `smart_unfold` tool is available via MCP
   - `smart_outline` tool is available via MCP
   - Searching returns folded structural views
   - Unfolding returns full source code
   - Outline returns file structure
5. Test graceful degradation: temporarily rename `node_modules/tree-sitter-wasms/out/` and verify the tools return empty results (not crashes)

### Anti-Pattern Guards
- Do NOT add tests in this phase — happy path first, tests after
- Do NOT add error handling beyond what's inherited from the MCP server's CallToolRequestSchema handler

### Verification
- [ ] All 3 tools functional in a live Claude Code session
- [ ] Folded views show correct structure for TypeScript files
- [ ] Token savings visible (folded view << full file read)
- [ ] No crashes when tree-sitter grammar WASM is unavailable
