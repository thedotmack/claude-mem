# Smart File Read Integration Plan

Integrate Smart File Read (tree-sitter CLI code search) as 3 new MCP tools in the claude-mem plugin, exposed via a `smart-explore` skill.

**Approach**: tree-sitter CLI via `execSync`. No WASM. No native Node.js bindings. The CLI binary ships with `tree-sitter-cli` npm package and grammar packages provide the language definitions. This is fully validated and working in the `smart-file-read/` worktree.

## Phase 0: Discovery Summary

### Architecture Findings

**MCP Server** (`src/servers/mcp-server.ts`):
- Tools defined as objects: `{ name, description, inputSchema, handler }`
- Registered via `setRequestHandler` for `ListToolsRequestSchema` / `CallToolRequestSchema`
- Currently 5 tools: `__IMPORTANT`, `search`, `timeline`, `get_observations`, `save_observation`
- Built with esbuild to `plugin/scripts/mcp-server.cjs` (CJS, node18 target)
- Only external: `bun:sqlite`

**Skill Structure** (`plugin/skills/<name>/SKILL.md`):
- YAML frontmatter: `name`, `description`
- Markdown body: workflow, parameters, examples
- References MCP tools by name directly in prose
- Auto-discovered from `plugin/skills/` directory

**Build** (`scripts/build-hooks.js`):
- esbuild bundles all source into single CJS files
- Native modules must be externalized (can't be bundled by esbuild)
- Runtime deps go in `plugin/package.json` (generated by build script at line 55-70) and installed via `smart-install.js` using `bun install`

### Key Decision: Direct Execution in MCP Server

Current memory tools delegate to the Worker HTTP API. Smart File Read is different:
- Read-only file I/O + AST parsing — no database, no state
- Sub-second response times — HTTP round-trip adds latency for no benefit
- No worker dependency — works independently of the memory system

**Decision: Direct execution.** The 3 smart_* tool handlers call parser/search functions directly, not via HTTP.

### Key Decision: tree-sitter CLI Approach

The parser shells out to `tree-sitter query` via `execSync`. Grammar packages (`tree-sitter-typescript`, etc.) provide the grammar files. `tree-sitter-cli` provides the binary.

**Why CLI over WASM/native:**
- CLI binary ships pre-built via `tree-sitter-cli` npm package — no compilation
- Grammar packages are needed only for their grammar files (resolved via `require.resolve`)
- Batch mode: one CLI call per language handles many files
- Validated: 2.95s for 192 files in batch mode

**Runtime deps** (must be externalized from esbuild and installed at plugin runtime):
- `tree-sitter-cli` — the binary
- 10 grammar packages — `tree-sitter-{javascript,typescript,python,go,rust,ruby,java,c,cpp}`

### Source Status

Working implementation in `smart-file-read/`:
- `parser.ts` (662 lines) — CLI-based AST parsing, batch queries, symbol extraction, formatting
- `search.ts` (316 lines) — directory walker, batch parsing, fuzzy matching, result formatting
- `index.ts` (248 lines) — standalone MCP server (reference for tool schemas, not ported directly)

All functions are synchronous (no async migration needed — CLI calls are `execSync`).

---

## Phase 1: Source Integration

**Goal**: Copy working parser and search code into the claude-mem source tree.

### Tasks

1. Create `src/services/smart-file-read/` directory

2. Copy `parser.ts` from `smart-file-read/parser.ts` — no changes needed. It's already CLI-based. All exports stay the same:
   - `parseFile(content, filePath)` → `FoldedFile`
   - `parseFilesBatch(files)` → `Map<string, FoldedFile>`
   - `formatFoldedView(file)` → `string`
   - `unfoldSymbol(content, filePath, symbolName)` → `string | null`
   - `detectLanguage(filePath)` → `string`
   - Types: `CodeSymbol`, `FoldedFile`

3. Copy `search.ts` from `smart-file-read/search.ts` — no changes needed. Exports:
   - `searchCodebase(rootDir, query, options)` → `Promise<SearchResult>`
   - `formatSearchResults(result, query)` → `string`
   - Types: `SearchResult`, `SymbolMatch`

### Verification
- [ ] `src/services/smart-file-read/parser.ts` exists, identical to `smart-file-read/parser.ts`
- [ ] `src/services/smart-file-read/search.ts` exists, identical to `smart-file-read/search.ts`
- [ ] `tsc --noEmit` passes

---

## Phase 2: MCP Tool Registration

**Goal**: Register `smart_search`, `smart_unfold`, and `smart_outline` as MCP tools on the existing claude-mem server.

### Tasks

1. Add imports to `src/servers/mcp-server.ts`:
   ```typescript
   import { searchCodebase, formatSearchResults } from '../services/smart-file-read/search.js';
   import { parseFile, formatFoldedView, unfoldSymbol } from '../services/smart-file-read/parser.js';
   import { readFile } from 'node:fs/promises';
   import { resolve, relative } from 'node:path';
   ```

2. Add 3 tool definitions to the `tools` array (after existing tools):

   **smart_search** — calls `searchCodebase()` + `formatSearchResults()` directly
   - inputSchema: `query` (string, required), `path` (string, default "."), `max_results` (number, default 20), `file_pattern` (string, optional)
   - Handler: resolve path, call `await searchCodebase(rootDir, query, options)`, format results

   **smart_unfold** — calls `unfoldSymbol()` directly
   - inputSchema: `file_path` (string, required), `symbol_name` (string, required), `path` (string, default ".")
   - Handler: read file, call `unfoldSymbol(content, filePath, symbolName)`
   - On miss: call `parseFile()` and list available symbols

   **smart_outline** — calls `parseFile()` + `formatFoldedView()` directly
   - inputSchema: `file_path` (string, required), `path` (string, default ".")
   - Handler: read file, call `parseFile()`, return `formatFoldedView()`

3. All handlers return MCP-format responses: `{ content: [{ type: 'text', text: string }], isError?: boolean }`

### Pattern to Follow
- Match existing tool style in `mcp-server.ts` lines 157-262
- Use JSON Schema (not Zod) for inputSchema — existing server uses raw JSON Schema
- snake_case tool names
- Add `readOnlyHint: true` annotation metadata

### Anti-Pattern Guards
- Do NOT add these tools to `TOOL_ENDPOINT_MAP` — they don't use HTTP delegation
- Do NOT add worker API endpoints — direct execution only
- Do NOT use Zod for schemas — existing tools use raw JSON Schema objects

### Verification
- [ ] 3 new tools in the `tools` array
- [ ] Tools use raw JSON Schema, not Zod
- [ ] No new entries in `TOOL_ENDPOINT_MAP`
- [ ] `tsc --noEmit` passes

---

## Phase 3: Build System Updates

**Goal**: Configure esbuild externals and runtime dependencies for tree-sitter CLI.

### Tasks

1. Update `scripts/build-hooks.js` MCP server build (~line 131) — add tree-sitter packages to externals:
   ```javascript
   external: [
     'bun:sqlite',
     'tree-sitter-cli',
     'tree-sitter-javascript',
     'tree-sitter-typescript',
     'tree-sitter-python',
     'tree-sitter-go',
     'tree-sitter-rust',
     'tree-sitter-ruby',
     'tree-sitter-java',
     'tree-sitter-c',
     'tree-sitter-cpp',
   ],
   ```
   These must be externalized because `parser.ts` uses `require.resolve()` to find grammar paths at runtime.

2. Update `scripts/build-hooks.js` plugin package.json generation (lines 55-70) — add tree-sitter deps:
   ```javascript
   dependencies: {
     'tree-sitter-cli': '^0.26.5',
     'tree-sitter-c': '^0.24.1',
     'tree-sitter-cpp': '^0.23.4',
     'tree-sitter-go': '^0.25.0',
     'tree-sitter-java': '^0.23.5',
     'tree-sitter-javascript': '^0.25.0',
     'tree-sitter-python': '^0.25.0',
     'tree-sitter-ruby': '^0.23.1',
     'tree-sitter-rust': '^0.24.0',
     'tree-sitter-typescript': '^0.23.2',
   }
   ```

3. Add tree-sitter packages to root `package.json` devDependencies (for type-checking and local dev), then `npm install --legacy-peer-deps`.

4. Remove `@chroma-core/default-embed` from plugin package.json dependencies (line 63) — Chroma now uses its own MCP subprocess.

### Why This Works at Runtime

The bundled `plugin/scripts/mcp-server.cjs` contains:
- `require("node:child_process").execSync(...)` — calls the CLI binary
- `require.resolve("tree-sitter-typescript/typescript/package.json")` — resolves grammar path from node_modules

`bun install` (via `smart-install.js`) installs packages in `plugin/node_modules/`. The `tree-sitter-cli` package includes a pre-built binary. Grammar packages install with `--legacy-peer-deps` if needed (they have peer deps on native tree-sitter, which we don't use).

### Verification
- [ ] `npm run build` succeeds
- [ ] `plugin/scripts/mcp-server.cjs` does NOT bundle tree-sitter packages inline (they're externalized)
- [ ] `plugin/package.json` includes `tree-sitter-cli` and all grammar packages

---

## Phase 4: Skill Creation

**Goal**: Create `plugin/skills/smart-explore/SKILL.md` following the mem-search pattern.

### Tasks

1. Create `plugin/skills/smart-explore/SKILL.md` using the validated content from `smart-file-read/PRELIMINARY-RESULTS.md` Part 2. Structure:

   **Frontmatter**:
   ```yaml
   ---
   name: smart-explore
   description: Token-optimized structural code search using tree-sitter AST parsing. Use instead of reading full files when you need to understand code structure, find functions, or explore a codebase efficiently.
   ---
   ```

   **Content**:
   - 3-layer progressive disclosure workflow (search -> outline -> unfold)
   - Tool parameters for all 3 tools
   - When to use / when NOT to use
   - Examples showing real usage patterns
   - Token economics summary

### Pattern to Follow
- `plugin/skills/mem-search/SKILL.md` for structure and tone
- Reference tools by name: `smart_search`, `smart_unfold`, `smart_outline`

### Verification
- [ ] `plugin/skills/smart-explore/SKILL.md` exists with valid YAML frontmatter
- [ ] All 3 tools documented with parameters
- [ ] Progressive disclosure workflow described

---

## Phase 5: Build, Test & Verify

**Goal**: End-to-end verification.

### Tasks

1. `npm install --legacy-peer-deps` — install tree-sitter packages
2. `npm run build` — verify clean build
3. `npm run build-and-sync` — deploy to local plugin directory
4. Start a new Claude Code session and verify:
   - `smart_search` tool is available via MCP
   - `smart_unfold` tool is available via MCP
   - `smart_outline` tool is available via MCP
   - Searching returns folded structural views
   - Unfolding returns full source code
   - Outline returns file structure

### Verification
- [ ] All 3 tools functional in a live Claude Code session
- [ ] Folded views show correct structure for TypeScript files
- [ ] Token savings visible (folded view << full file read)
