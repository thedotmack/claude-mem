---
title: "Worker Service"
description: "HTTP API and Node.js process management"
---

# Worker Service

The worker service is a long-running HTTP API built with Express.js and managed by Node.js. It processes observations through the Claude Agent SDK separately from hook execution to prevent timeout issues.

## Overview

- **Technology**: Express.js HTTP server
- **Runtime**: Node.js 18+
- **Process Manager**: Native Node.js process management via ProcessManager
- **Port**: Fixed port 37777 (configurable via `MAGIC_CLAUDE_MEM_WORKER_PORT`)
- **Location**: `src/services/worker-service.ts`
- **Built Output**: `plugin/scripts/worker-service.cjs`
- **Model**: Configurable via `MAGIC_CLAUDE_MEM_MODEL` setting (default: haiku)

## REST API Endpoints

The worker service exposes HTTP endpoints organized into eight route modules:

### Viewer & Health Endpoints

#### 1. Viewer UI
```
GET /
```

**Purpose**: Serves the web-based viewer UI (v5.1.0+)

**Response**: HTML page with embedded React application

**Features**:
- Real-time memory stream visualization
- Infinite scroll pagination
- Project filtering
- SSE-based live updates
- Theme toggle (light/dark mode) as of v5.1.2

#### 2. Version
```
GET /api/version
```

**Purpose**: Returns the worker's baked-in version (set at build time via esbuild `define`)

**Response**:
```json
{
  "version": "9.8.3"
}
```

**Use Case**: Used by hooks to detect version mismatches between the installed plugin and the running worker process. If a mismatch is detected, the worker is automatically restarted.

#### 3. Health Check
```
GET /health
```

**Purpose**: Worker health status check

**Response**:
```json
{
  "status": "ok",
  "uptime": 12345,
  "port": 37777
}
```

#### 3. Server-Sent Events Stream
```
GET /stream
```

**Purpose**: Real-time updates for viewer UI

**Response**: SSE stream with events:
- `observation-created`: New observation added
- `session-summary-created`: New summary generated
- `user-prompt-created`: New prompt recorded

**Event Format**:
```
event: observation-created
data: {"id": 123, "title": "...", ...}
```

### Data Retrieval Endpoints

#### 4. Get Prompts
```
GET /api/prompts?project=my-project&limit=20&offset=0
```

**Purpose**: Retrieve paginated user prompts

**Query Parameters**:
- `project` (optional): Filter by project name
- `limit` (default: 20): Number of results
- `offset` (default: 0): Pagination offset

**Response**:
```json
{
  "prompts": [{
    "id": 1,
    "session_id": "abc123",
    "prompt": "User's prompt text",
    "prompt_number": 1,
    "created_at": "2025-11-06T10:30:00Z"
  }],
  "total": 150,
  "hasMore": true
}
```

#### 5. Get Observations
```
GET /api/observations?project=my-project&limit=20&offset=0
```

**Purpose**: Retrieve paginated observations

**Query Parameters**:
- `project` (optional): Filter by project name
- `limit` (default: 20): Number of results
- `offset` (default: 0): Pagination offset

**Response**:
```json
{
  "observations": [{
    "id": 123,
    "title": "Fix authentication bug",
    "type": "bugfix",
    "narrative": "...",
    "created_at": "2025-11-06T10:30:00Z"
  }],
  "total": 500,
  "hasMore": true
}
```

#### 6. Get Summaries
```
GET /api/summaries?project=my-project&limit=20&offset=0
```

**Purpose**: Retrieve paginated session summaries

**Query Parameters**:
- `project` (optional): Filter by project name
- `limit` (default: 20): Number of results
- `offset` (default: 0): Pagination offset

**Response**:
```json
{
  "summaries": [{
    "id": 456,
    "session_id": "abc123",
    "request": "User's original request",
    "completed": "Work finished",
    "created_at": "2025-11-06T10:30:00Z"
  }],
  "total": 100,
  "hasMore": true
}
```

#### 7. Get Observation by ID
```
GET /api/observation/:id
```

**Purpose**: Retrieve a single observation by its ID

**Path Parameters**:
- `id` (required): Observation ID

**Response**:
```json
{
  "id": 123,
  "memory_session_id": "abc123",
  "project": "my-project",
  "type": "bugfix",
  "title": "Fix authentication bug",
  "narrative": "...",
  "created_at": "2025-11-06T10:30:00Z",
  "created_at_epoch": 1730886600000
}
```

**Error Response** (404):
```json
{
  "error": "Observation #123 not found"
}
```

#### 8. Get Observations by IDs (Batch)
```
POST /api/observations/batch
```

**Purpose**: Retrieve multiple observations by their IDs in a single request

**Request Body**:
```json
{
  "ids": [123, 456, 789],
  "orderBy": "date_desc",
  "limit": 10,
  "project": "my-project"
}
```

**Body Parameters**:
- `ids` (required): Array of observation IDs
- `orderBy` (optional): Sort order - `date_desc` or `date_asc` (default: `date_desc`)
- `limit` (optional): Maximum number of results to return
- `project` (optional): Filter by project name

**Response**:
```json
[
  {
    "id": 789,
    "memory_session_id": "abc123",
    "project": "my-project",
    "type": "feature",
    "title": "Add new feature",
    "narrative": "...",
    "created_at": "2025-11-06T12:00:00Z",
    "created_at_epoch": 1730891400000
  },
  {
    "id": 456,
    "memory_session_id": "abc124",
    "project": "my-project",
    "type": "bugfix",
    "title": "Fix authentication bug",
    "narrative": "...",
    "created_at": "2025-11-06T10:30:00Z",
    "created_at_epoch": 1730886600000
  }
]
```

**Error Responses**:
- `400 Bad Request`: `{"error": "ids must be an array of numbers"}`
- `400 Bad Request`: `{"error": "All ids must be integers"}`

**Use Case**: This endpoint is used by the `get_observations` MCP tool to efficiently retrieve multiple observations in a single request, avoiding the overhead of multiple individual requests.

#### 9. Get Session by ID
```
GET /api/session/:id
```

**Purpose**: Retrieve a single session by its ID

**Path Parameters**:
- `id` (required): Session ID

**Response**:
```json
{
  "id": 456,
  "memory_session_id": "abc123",
  "project": "my-project",
  "request": "User's original request",
  "completed": "Work finished",
  "created_at": "2025-11-06T10:30:00Z"
}
```

**Error Response** (404):
```json
{
  "error": "Session #456 not found"
}
```

#### 10. Get Prompt by ID
```
GET /api/prompt/:id
```

**Purpose**: Retrieve a single user prompt by its ID

**Path Parameters**:
- `id` (required): Prompt ID

**Response**:
```json
{
  "id": 1,
  "session_id": "abc123",
  "prompt": "User's prompt text",
  "prompt_number": 1,
  "created_at": "2025-11-06T10:30:00Z"
}
```

**Error Response** (404):
```json
{
  "error": "Prompt #1 not found"
}
```

#### 12. Get Stats
```
GET /api/stats
```

**Purpose**: Get database statistics by project

**Response**:
```json
{
  "byProject": {
    "my-project": {
      "observations": 245,
      "summaries": 12,
      "prompts": 48
    },
    "other-project": {
      "observations": 156,
      "summaries": 8,
      "prompts": 32
    }
  },
  "total": {
    "observations": 401,
    "summaries": 20,
    "prompts": 80,
    "sessions": 20
  }
}
```

#### 13. Get Projects
```
GET /api/projects
```

**Purpose**: Get list of distinct projects from observations

**Response**:
```json
{
  "projects": ["my-project", "other-project", "test-project"]
}
```

#### 14. Token Analytics
```
GET /api/analytics?project=my-project&range=7d
```

**Purpose**: Aggregate token usage statistics for the viewer analytics dashboard

**Query Parameters**:
- `project` (optional): Filter by project name
- `range` (optional): Time range — `24h`, `7d`, `30d`, `90d`, `all` (default: `7d`)

**Response**:
```json
{
  "read": 45230,
  "work": 312500,
  "recalled": 22100,
  "saved": 290400,
  "observations": 156
}
```

**Fields**:
- `read`: Total tokens to read all observations in range
- `work`: Total tokens spent on research/building that produced those observations
- `recalled`: Tokens actually recalled (injected into sessions)
- `saved`: Work tokens minus recalled tokens (savings from reuse)
- `observations`: Number of observations in the time range

### Settings Endpoints

#### 14. Get Settings
```
GET /api/settings
```

**Purpose**: Retrieve user settings

**Response**:
```json
{
  "sidebarOpen": true,
  "selectedProject": "my-project",
  "theme": "dark"
}
```

#### 15. Save Settings
```
POST /api/settings
```

**Purpose**: Persist user settings

**Request Body**:
```json
{
  "sidebarOpen": false,
  "selectedProject": "other-project",
  "theme": "light"
}
```

**Response**:
```json
{
  "success": true
}
```

### Queue Management Endpoints

#### 16. Get Pending Queue Status
```
GET /api/pending-queue
```

**Purpose**: View current processing queue status and identify stuck messages

**Response**:
```json
{
  "queue": {
    "messages": [
      {
        "id": 123,
        "session_db_id": 45,
        "claude_session_id": "abc123",
        "message_type": "observation",
        "status": "pending",
        "retry_count": 0,
        "created_at_epoch": 1730886600000,
        "started_processing_at_epoch": null,
        "completed_at_epoch": null
      }
    ],
    "totalPending": 5,
    "totalProcessing": 2,
    "totalFailed": 0,
    "stuckCount": 1
  },
  "recentlyProcessed": [
    {
      "id": 122,
      "session_db_id": 44,
      "status": "processed",
      "completed_at_epoch": 1730886500000
    }
  ],
  "sessionsWithPendingWork": [44, 45, 46]
}
```

**Status Definitions**:
- `pending`: Message queued, not yet processed
- `processing`: Message currently being processed by SDK agent
- `processed`: Message completed successfully
- `failed`: Message failed after max retry attempts (3 by default)

**Stuck Detection**: Messages in `processing` status for >5 minutes are considered stuck and included in `stuckCount`

**Use Case**: Check queue health after worker crashes or restarts to identify unprocessed observations

#### 17. Trigger Manual Recovery
```
POST /api/pending-queue/process
```

**Purpose**: Manually trigger processing of pending queues (replaces automatic recovery in v5.x+)

**Request Body**:
```json
{
  "sessionLimit": 10
}
```

**Body Parameters**:
- `sessionLimit` (optional): Maximum number of sessions to process (default: 10, max: 100)

**Response**:
```json
{
  "success": true,
  "totalPendingSessions": 15,
  "sessionsStarted": 10,
  "sessionsSkipped": 2,
  "startedSessionIds": [44, 45, 46, 47, 48, 49, 50, 51, 52, 53]
}
```

**Response Fields**:
- `totalPendingSessions`: Total sessions with pending messages in database
- `sessionsStarted`: Number of sessions we started processing this request
- `sessionsSkipped`: Sessions already actively processing (not restarted)
- `startedSessionIds`: Database IDs of sessions started

**Behavior**:
- Processes up to `sessionLimit` sessions with pending work
- Skips sessions already actively processing (prevents duplicate agents)
- Starts non-blocking SDK agents for each session
- Returns immediately with status (processing continues in background)

**Use Case**: Manually recover stuck observations after worker crashes, or when automatic recovery was disabled

**Recovery Strategy Note**: As of v5.x, automatic recovery on worker startup is disabled by default. Users must manually trigger recovery using this endpoint or the CLI tool (`npx tsx scripts/check-pending-queue.ts`) to maintain explicit control over reprocessing.

### Session Management Endpoints

#### 19. Initialize Session
```
POST /sessions/:sessionDbId/init
```

**Request Body**:
```json
{
  "memory_session_id": "abc-123",
  "project": "my-project"
}
```

**Response**:
```json
{
  "success": true,
  "session_id": "abc-123"
}
```

#### 20. Add Observation
```
POST /sessions/:sessionDbId/observations
```

**Request Body**:
```json
{
  "tool_name": "Read",
  "tool_input": {...},
  "tool_result": "...",
  "correlation_id": "xyz-789"
}
```

**Response**:
```json
{
  "success": true,
  "observation_id": 123
}
```

#### 21. Generate Summary
```
POST /sessions/:sessionDbId/summarize
```

**Request Body**:
```json
{
  "trigger": "stop"
}
```

**Response**:
```json
{
  "success": true,
  "summary_id": 456
}
```

#### 22. Session Status
```
GET /sessions/:sessionDbId/status
```

**Response**:
```json
{
  "session_id": "abc-123",
  "status": "active",
  "observation_count": 42,
  "summary_count": 1
}
```

#### 23. Delete Session
```
DELETE /sessions/:sessionDbId
```

**Response**:
```json
{
  "success": true
}
```

**Note**: As of v4.1.0, the cleanup hook no longer calls this endpoint. Sessions are marked complete instead of deleted to allow graceful worker shutdown.

### Active Session Management Endpoints

These endpoints were introduced in v9.5.0 to manage stale sessions that accumulate when Claude Code sessions end without proper cleanup (e.g., terminal closes, crashes). They are served by `ActiveSessionRoutes` and integrated with `SummaryQueueService` for queue-first, close-second session teardown.

#### 24. Get Active Sessions
```
GET /api/sessions/active
```

**Purpose**: List all active sessions with stale detection metadata (v9.5.0+)

**Response**:
```json
{
  "sessions": [
    {
      "id": 45,
      "content_session_id": "abc-123",
      "project": "my-project",
      "user_prompt": "Fix the login bug",
      "started_at_epoch": 1730886600000,
      "is_stale": false,
      "duration_ms": 1200000
    },
    {
      "id": 38,
      "content_session_id": "xyz-789",
      "project": "other-project",
      "user_prompt": "Add unit tests",
      "started_at_epoch": 1730879400000,
      "is_stale": true,
      "duration_ms": 8400000
    }
  ],
  "staleCount": 1,
  "totalCount": 2
}
```

**Fields**:
- `is_stale`: `true` if the session has been active for longer than 1 hour (the stale threshold)
- `duration_ms`: Milliseconds since the session started
- `staleCount`: Number of sessions exceeding the stale threshold
- `totalCount`: Total active sessions

**Use Case**: The viewer UI uses this to display active session status and offer manual close actions for orphaned sessions.

#### 25. Close Session
```
POST /api/sessions/:id/close
```

**Purpose**: Close a single active session by its database row ID (v9.5.0+). Queues a summary before closing if `SummaryQueueService` is available (v9.8.3+).

**Path Parameters**:
- `id` (required): Session database ID

**Response**:
```json
{
  "success": true,
  "summaryQueued": true
}
```

**Response Fields**:
- `success`: Whether the session was closed (status set to `completed`)
- `summaryQueued`: Whether a summary was queued before closing (requires `SummaryQueueService`)

**Error Response** (404):
```json
{
  "error": "Session not found or not active"
}
```

**Behavior** (queue-first, close-second):
1. If `SummaryQueueService` is available, attempts to queue a summary for the session
2. Summary queueing checks: does the session have a `memory_session_id`? Does it already have a summary?
3. If the session has unsummarized observations, `queueSummarize()` is called with the last observation text as context
4. The session is then closed (status set to `completed`) regardless of whether summary queueing succeeded
5. Summary failure is best-effort and never blocks the close operation

#### 26. Close Stale Sessions
```
POST /api/sessions/close-stale
```

**Purpose**: Close all active sessions that have been running longer than 1 hour (v9.5.0+). Queues summaries for each stale session before closing (v9.8.3+).

**Response**:
```json
{
  "closedCount": 3,
  "summariesQueued": 2
}
```

**Response Fields**:
- `closedCount`: Number of sessions closed
- `summariesQueued`: Number of summaries successfully queued before closing

**Behavior**:
1. Queries all active sessions older than the stale threshold (1 hour)
2. For each stale session, attempts to queue a summary (same logic as single-session close)
3. Closes all stale sessions in a single database update
4. Summary failures for individual sessions are logged but do not prevent other sessions from being processed

**Use Case**: Periodic cleanup of orphaned sessions, callable from the viewer UI or automation scripts.

## SummaryQueueService

Introduced in v9.8.3, the `SummaryQueueService` ensures that sessions closed via the API (rather than through the normal hook lifecycle) still get summaries generated. It implements the **queue-first, close-second** pattern.

### Architecture

```
┌──────────────────────┐     ┌─────────────────────┐     ┌──────────────────┐
│  ActiveSessionRoutes │────▶│  SummaryQueueService │────▶│  SessionManager  │
│  (HTTP handlers)     │     │  (orchestrator)      │     │  (queueSummarize)│
└──────────────────────┘     └──────┬──────────────┘     └──────────────────┘
                                    │
                                    ▼
                             ┌─────────────────────────┐
                             │  SessionEventBroadcaster │
                             │  (SSE notification)      │
                             └─────────────────────────┘
```

### Wiring

`SummaryQueueService` is instantiated in `WorkerService` and injected into `ActiveSessionRoutes`:

```typescript
this.summaryQueueService = new SummaryQueueService({
  sessionManager: this.sessionManager,
  eventBroadcaster: this.sessionEventBroadcaster,
});

this.server.registerRoutes(new ActiveSessionRoutes(
  this.dbManager,
  this.summaryQueueService,
));
```

### Queue-First, Close-Second Pattern

When a session is closed via the API:

1. **Queue**: `SummaryQueueService.queueSummary()` calls `SessionManager.queueSummarize()`, which persists a `summarize` message to the pending queue database **before** adding it to the in-memory queue. This ensures the request survives worker crashes.
2. **Broadcast**: `SessionEventBroadcaster.broadcastSummarizeQueued()` notifies connected viewer clients that processing status changed.
3. **Close**: The session status is set to `completed` in the database.
4. **Process**: The SDK agent picks up the queued summarize message asynchronously and generates the summary.

Summary queueing is skipped when:
- The session has no `memory_session_id` (never initialized with the SDK)
- The session already has a summary
- `SummaryQueueService` is not available (graceful degradation)

### Error Handling

Summary queueing failures are best-effort. If `queueSummary()` fails, the error is logged and the session is still closed. This prevents a summary generation failure from leaving sessions permanently stuck in `active` status.

## Session Completion Lifecycle

Sessions track their processing status through a lifecycle:

```
active → completed → active (on new prompt)
```

- **`active`**: Session is receiving observations/summaries
- **`completed`**: All processing finished. Reached via one of two paths:
  - **Normal flow**: `completeSession` called from `ResponseProcessor` after the atomic transaction stores observations and summary
  - **API close** (v9.5.0+): `POST /api/sessions/:id/close` or `POST /api/sessions/close-stale` sets status to `completed`. As of v9.8.3, a summary is queued before closing (queue-first, close-second pattern).
- **Back to `active`**: When a new prompt arrives for a completed session, `createSDKSession` resets status to `active`

This lifecycle enables:
- Distinguishing between sessions still being processed and those that are done
- Proper session reuse when the same Claude session sends multiple prompts
- Recovery tools can differentiate stuck sessions from completed ones
- Manual cleanup of orphaned sessions via the API without losing summary data

## Node.js Process Management

### Overview

The worker is managed by the `ProcessManager` module (`src/services/infrastructure/ProcessManager.ts`) which handles:
- Process spawning with Node.js runtime (detached daemon)
- Structured PID file at `~/.magic-claude-mem/worker.pid` with process metadata
- Health checks with automatic retry
- Graceful shutdown with SIGTERM/SIGKILL fallback
- Orphaned child process cleanup (chroma-mcp processes from previous sessions)

### PID File Format

The PID file (`~/.magic-claude-mem/worker.pid`) stores structured JSON with process metadata for crash recovery and diagnostics:

```json
{
  "pid": 12345,
  "port": 37777,
  "startedAt": "2026-02-26T10:30:00.000Z",
  "nodeVersion": "v22.14.0"
}
```

The `readPidFile()` function handles corrupted or missing PID files gracefully, returning `null` so the worker can be restarted cleanly. The `nodeVersion` field (added for diagnostics) tracks which Node.js runtime the worker was spawned with.

### Commands

```bash
# Start worker (auto-starts on first session)
npm run worker:start

# Stop worker
npm run worker:stop

# Restart worker
npm run worker:restart

# View logs
npm run worker:logs

# Check status
npm run worker:status
```

### Auto-Start Behavior

The worker service auto-starts when the SessionStart hook fires. Manual start is optional.

### Auto-Restart on Version Mismatch

When the plugin is updated (e.g., via `npm run sync-marketplace`), the running worker process may still be executing the old version. Starting with v9.4.4, the `ensureWorkerRunning()` function (`src/shared/worker-utils.ts`) called by every hook detects this automatically:

1. **Health check** — Verifies the worker is responding via `isWorkerHealthy()`
2. **Version check** — `checkWorkerVersion()` calls `GET /api/version` and compares with the installed plugin version (read from `package.json`). If the version cannot be determined, it assumes a match to avoid unnecessary restarts.
3. **Auto-restart** — If versions differ, `restartWorker()` executes `node worker-service.cjs restart` with a 45-second timeout and verifies post-restart health
4. **Port cache clear** — After restart, `clearPortCache()` is called so subsequent health checks re-read the port from settings (the new version may use a different port)

All fetch calls to the worker include a 5-second timeout (`AbortSignal.timeout`) to prevent indefinite hangs. If restart fails, hooks proceed gracefully without blocking the session — the worker will be retried on the next hook invocation.

### Node.js Requirement

Node.js 18+ is required to run the worker service. Install via your preferred method:

- **nvm**: `nvm install 18`
- **nvs**: `nvs add 18`
- **Direct download**: https://nodejs.org/

## Claude Agent SDK Integration

The worker service routes observations to the Claude Agent SDK for AI-powered processing:

### Processing Flow

1. **Message Queue**: Hooks send messages (observations/summaries) to the worker via HTTP. Messages are claimed and deleted from the queue atomically (claim-and-delete pattern)
2. **SDK Processing**: Messages sent to Claude via Agent SDK with iterative processing
3. **XML Parsing**: Responses parsed for structured data (observations with type, title, narrative, facts, concepts, files)
4. **Atomic Storage**: Parsed observations + summary stored in a single SQLite transaction
5. **Async Sync**: Chroma vector embeddings synced fire-and-forget (failures are non-critical)
6. **SSE Broadcast**: New items broadcast to connected viewer UI clients

### History Compaction

The SDK agent uses history compaction instead of simple truncation to manage conversation context:
- When conversation history exceeds the context limit, older messages are summarized rather than dropped
- This preserves the narrative arc while staying within token budgets
- Summary messages and observation results have priority ordering in the queue

### SDK Components

- **Prompts** (`src/sdk/prompts.ts`): Builds XML-structured prompts
- **Parser** (`src/sdk/parser.ts`): Parses Claude's XML responses
- **Worker** (`src/sdk/worker.ts`): Main SDK agent loop

### Model Configuration

Set the AI model used for processing via settings:

```json
{
  "MAGIC_CLAUDE_MEM_MODEL": "haiku"
}
```

Available shorthand models (forward to latest version):
- `haiku` - Fast, cost-efficient (default)
- `sonnet` - Balanced
- `opus` - Most capable

## Port Allocation

The worker uses a fixed port (37777 by default) for consistent communication:

- **Default**: Port 37777
- **Override**: Set `MAGIC_CLAUDE_MEM_WORKER_PORT` environment variable
- **Port File**: `${CLAUDE_PLUGIN_ROOT}/data/worker.port` tracks current port

If port 37777 is in use, the worker will fail to start. Set a custom port via environment variable.

## Data Storage

The worker service stores data in the user data directory:

```
~/.magic-claude-mem/
├── magic-claude-mem.db           # SQLite database (better-sqlite3)
├── worker.pid              # Structured JSON PID file (pid, port, startedAt, nodeVersion)
├── settings.json           # User settings
└── logs/
    └── worker-YYYY-MM-DD.log  # Daily rotating logs
```

## Error Handling

The worker implements graceful degradation:

- **Database Errors**: Logged but don't crash the service
- **SDK Errors**: Retried with exponential backoff
- **Network Errors**: Logged and skipped
- **Invalid Input**: Validated and rejected with error response

## Performance

- **Async Processing**: Observations processed asynchronously
- **In-Memory Queue**: Fast observation accumulation
- **Batch Processing**: Multiple observations processed together
- **Connection Pooling**: SQLite connections reused

## Troubleshooting

See [Troubleshooting - Worker Issues](../troubleshooting.md#worker-service-issues) for common problems and solutions.
