#!/usr/bin/env node
import{stdin as d}from"process";import w from"path";import{homedir as D}from"os";import{existsSync as E,readFileSync as x}from"fs";import{join as e,dirname as S,basename as O}from"path";import{homedir as g}from"os";import{fileURLToPath as y}from"url";function k(){return typeof __dirname<"u"?__dirname:S(y(import.meta.url))}var b=k(),r=process.env.CLAUDE_MEM_DATA_DIR||e(g(),".claude-mem"),u=process.env.CLAUDE_CONFIG_DIR||e(g(),".claude"),U=e(r,"archives"),j=e(r,"logs"),M=e(r,"trash"),N=e(r,"backups"),H=e(r,"settings.json"),W=e(r,"claude-mem.db"),F=e(r,"vector-db"),G=e(u,"settings.json"),K=e(u,"commands"),B=e(u,"CLAUDE.md");function f(){try{let t=w.join(D(),".claude-mem","settings.json");if(E(t)){let o=JSON.parse(x(t,"utf-8")),n=parseInt(o.env?.CLAUDE_MEM_WORKER_PORT,10);if(!isNaN(n))return n}}catch{}return parseInt(process.env.CLAUDE_MEM_WORKER_PORT||"37777",10)}import{appendFileSync as R}from"fs";import{homedir as T}from"os";import{join as A}from"path";var P=A(T(),".claude-mem","silent.log");function i(t,o,n=""){let a=new Date().toISOString(),p=((new Error().stack||"").split(`
`)[2]||"").match(/at\s+(?:.*\s+)?\(?([^:]+):(\d+):(\d+)\)?/),h=p?`${p[1].split("/").pop()}:${p[2]}`:"unknown",c=`[${a}] [${h}] ${t}`;if(o!==void 0)try{c+=` ${JSON.stringify(o)}`}catch(m){c+=` [stringify error: ${m}]`}c+=`
`;try{R(P,c)}catch(m){console.error("[silent-debug] Failed to write to log:",m)}return n}async function _(t){i("[cleanup-hook] Hook fired",{session_id:t?.session_id,cwd:t?.cwd,reason:t?.reason}),t||(console.log("No input provided - this script is designed to run as a Claude Code SessionEnd hook"),console.log(`
Expected input format:`),console.log(JSON.stringify({session_id:"string",cwd:"string",transcript_path:"string",hook_event_name:"SessionEnd",reason:"exit"},null,2)),process.exit(0));let{session_id:o,reason:n}=t,a=f();try{let s=await fetch(`http://127.0.0.1:${a}/api/sessions/complete`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({claudeSessionId:o,reason:n}),signal:AbortSignal.timeout(2e3)});if(s.ok){let l=await s.json();i("[cleanup-hook] Session cleanup completed",l)}else i("[cleanup-hook] Session not found or already cleaned up")}catch(s){i("[cleanup-hook] Worker not reachable (non-critical)",{error:s.message})}console.log('{"continue": true, "suppressOutput": true}'),process.exit(0)}if(d.isTTY)_(void 0);else{let t="";d.on("data",o=>t+=o),d.on("end",async()=>{let o=t?JSON.parse(t):void 0;await _(o)})}
