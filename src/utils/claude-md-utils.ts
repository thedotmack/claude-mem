/**
 * CLAUDE.md File Utilities
 *
 * Shared utilities for writing folder-level CLAUDE.md files with
 * auto-generated context sections. Preserves user content outside
 * <claude-mem-context> tags.
 */

import { existsSync, readFileSync, writeFileSync, renameSync, mkdirSync } from 'fs';
import path from 'path';
import { logger } from './logger.js';

/**
 * Replace tagged content in existing file, preserving content outside tags.
 *
 * Handles three cases:
 * 1. No existing content â†’ wraps new content in tags
 * 2. Has existing tags â†’ replaces only tagged section
 * 3. No tags in existing content â†’ appends tagged content at end
 */
export function replaceTaggedContent(existingContent: string, newContent: string): string {
  const startTag = '<claude-mem-context>';
  const endTag = '</claude-mem-context>';

  // If no existing content, wrap new content in tags
  if (!existingContent) {
    return `${startTag}\n${newContent}\n${endTag}`;
  }

  // If existing has tags, replace only tagged section
  const startIdx = existingContent.indexOf(startTag);
  const endIdx = existingContent.indexOf(endTag);

  if (startIdx !== -1 && endIdx !== -1) {
    return existingContent.substring(0, startIdx) +
           `${startTag}\n${newContent}\n${endTag}` +
           existingContent.substring(endIdx + endTag.length);
  }

  // If no tags exist, append tagged content at end
  return existingContent + `\n\n${startTag}\n${newContent}\n${endTag}`;
}

/**
 * Write CLAUDE.md file to folder with atomic writes.
 * Creates directory structure if needed.
 *
 * @param folderPath - Absolute path to the folder
 * @param newContent - Content to write inside tags
 */
export function writeClaudeMdToFolder(folderPath: string, newContent: string): void {
  const claudeMdPath = path.join(folderPath, 'CLAUDE.md');
  const tempFile = `${claudeMdPath}.tmp`;

  // Ensure directory exists
  mkdirSync(folderPath, { recursive: true });

  // Read existing content if file exists
  let existingContent = '';
  if (existsSync(claudeMdPath)) {
    existingContent = readFileSync(claudeMdPath, 'utf-8');
  }

  // Replace only tagged content, preserve user content
  const finalContent = replaceTaggedContent(existingContent, newContent);

  // Atomic write: temp file + rename
  writeFileSync(tempFile, finalContent);
  renameSync(tempFile, claudeMdPath);
}

/**
 * Format timeline text from API response to compact CLAUDE.md format.
 *
 * @param timelineText - Raw API response text
 * @returns Formatted markdown with date headers and compact table
 */
export function formatTimelineForClaudeMd(timelineText: string): string {
  const lines: string[] = [];
  lines.push('# Recent Activity');
  lines.push('');
  lines.push('<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->');
  lines.push('');

  // Parse the API response to extract observation rows
  const apiLines = timelineText.split('\n');

  // Skip header lines and find table rows (start with "| #")
  const observations: Array<{ time: string; type: string; title: string }> = [];

  let lastTime = '';

  for (const line of apiLines) {
    // Match observation/session rows: | #123 | 4:30 PM | ðŸ”§ | Title | ~250 | ... |
    // Also handles ditto marks: | #124 | â€³ | ðŸ”§ | Title | ~250 | ... |
    const match = line.match(/^\|\s*#[S]?\d+\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|/);
    if (match) {
      const [, timeStr, typeEmoji, title] = match;

      // Map emoji back to type text (from code.json mode config)
      const typeMap: Record<string, string> = {
        'ðŸ”´': 'bugfix',
        'ðŸŸ£': 'feature',
        'ðŸ”„': 'refactor',
        'âœ…': 'change',
        'ðŸ”µ': 'discovery',
        'âš–ï¸': 'decision',
        'ðŸŽ¯': 'session',
        'ðŸ’¬': 'prompt'
      };

      const type = typeMap[typeEmoji.trim()] || 'other';

      // Handle ditto mark (â€³) - use last time
      let formattedTime: string;
      if (timeStr.trim() === 'â€³' || timeStr.trim() === '"') {
        formattedTime = lastTime;
      } else {
        // Convert time to lowercase format (4:30 PM -> 4:30pm)
        formattedTime = timeStr.trim().toLowerCase().replace(/\s+/g, '');
        lastTime = formattedTime;
      }

      observations.push({
        time: formattedTime,
        type,
        title: title.trim()
      });
    }
  }

  if (observations.length === 0) {
    lines.push('*No recent activity*');
    return lines.join('\n');
  }

  // Simple approach: Group all recent observations under a single date header.
  // Since we limit to 10 recent observations per folder, they're typically from
  // the same day or recent days. Using "Recent" as the date header keeps it simple.

  lines.push('### Recent');
  lines.push('');
  lines.push('| Time | Type | Title |');
  lines.push('|------|------|-------|');

  for (const obs of observations) {
    lines.push(`| ${obs.time} | ${obs.type} | ${obs.title} |`);
  }

  return lines.join('\n');
}

/**
 * Update CLAUDE.md files for folders containing the given files.
 * Fetches timeline from worker API and writes formatted content.
 *
 * @param filePaths - Array of absolute file paths (modified or read)
 * @param project - Project identifier for API query
 * @param port - Worker API port
 */
export async function updateFolderClaudeMdFiles(
  filePaths: string[],
  project: string,
  port: number
): Promise<void> {
  // Extract unique folder paths from file paths
  const folderPaths = new Set<string>();
  for (const filePath of filePaths) {
    if (!filePath || filePath === '') continue;
    const folderPath = path.dirname(filePath);
    if (folderPath && folderPath !== '.' && folderPath !== '/') {
      folderPaths.add(folderPath);
    }
  }

  if (folderPaths.size === 0) return;

  logger.debug('FOLDER_INDEX', 'Updating CLAUDE.md files', {
    project,
    folderCount: folderPaths.size
  });

  // Process each folder
  for (const folderPath of folderPaths) {
    try {
      // Fetch timeline via existing API
      const response = await fetch(
        `http://127.0.0.1:${port}/api/search/by-file?filePath=${encodeURIComponent(folderPath)}&limit=10&project=${encodeURIComponent(project)}`
      );

      if (!response.ok) {
        logger.warn('FOLDER_INDEX', 'Failed to fetch timeline', { folderPath, status: response.status });
        continue;
      }

      const result = await response.json();
      if (!result.content?.[0]?.text) {
        logger.debug('FOLDER_INDEX', 'No content for folder', { folderPath });
        continue;
      }

      const formatted = formatTimelineForClaudeMd(result.content[0].text);
      writeClaudeMdToFolder(folderPath, formatted);

      logger.debug('FOLDER_INDEX', 'Updated CLAUDE.md', { folderPath });
    } catch (error) {
      // Fire-and-forget: log warning but don't fail
      logger.warn('FOLDER_INDEX', 'Failed to update CLAUDE.md', { folderPath }, error as Error);
    }
  }
}
