[{"type":"text","text":"## Review commit against architecture guidelines: MCP as DRY search source, HTTP API routes through MCP, MCP not deprecated\n*Source: claude-mem://session/b1a1c481-6560-41bf-a0d3-23e448584f08*\n\n**Completed:** Build and deployment pipeline executed successfully for claude-mem version 6.0.9. All components compiled including worker-service.cjs (1337.16 KB), search-server.mjs (332.02 KB), seven hooks (context, new, save, summary, cleanup, user-message), and React viewer UI bundle. All 11,751 files synced to marketplace location (~/.claude/plugins/marketplaces/thedotmack/), dependencies refreshed via npm install, and worker service restarted to activate new code.\n\n**Learned:** The search architecture follows a clear layered pattern: MCP contains the single source of truth for search logic, HTTP API endpoints act as a thin routing layer that delegates to MCP, and this prevents code duplication. The system maintains 6 public-facing endpoints (/api/search, /api/timeline, /api/decisions, /api/changes, /api/how-it-works, /api/contextualize) with granular endpoints preserved for backward compatibility. The unified /api/search endpoint accepts catch-all parameters (type, obs_type, concepts, files) that replace the need for specialized endpoints.\n\n**Investigated:** A commit review was requested to verify compliance with established search architecture principles. The architecture mandates that MCP (Model Context Protocol) serves as the canonical, DRY search implementation with HTTP API routing through it.\n\n**Next Steps:** Awaiting confirmation that the commit passes architecture review or identification of any violations of the MCP-as-DRY-source principle where HTTP API might be duplicating search logic instead of routing through MCP.\n\n**Notes:** The unified search API design demonstrates strong architectural discipline by consolidating multiple specialized endpoints into a single parameterized endpoint while maintaining backward compatibility. The build output shows healthy file sizes with the worker service as the largest component at ~1.3 MB, which is reasonable for a service handling search, MCP integration, and worker orchestration.\n\n---\nDate: 11/17/2025\n\n---\n\n## Clarifying whether semantic shortcuts should return simple search results or contextual timelines\n*Source: claude-mem://session/b1a1c481-6560-41bf-a0d3-23e448584f08*\n\n**Completed:** The primary Claude identified the architectural decision point and presented two clear options to the user with concrete examples showing the difference between search-based responses (returning flat lists) versus timeline-based responses (returning anchor observations with contextual timelines).\n\n**Learned:** Semantic shortcuts like `/api/decisions`, `/api/changes`, and `/api/how-it-works` currently function as search shortcuts that filter observations by concept tags. The user's question suggested they might expect timeline functionality, prompting architectural clarification about whether these endpoints should evolve from simple filtered lists into richer timeline-based responses that provide chronological context around concept evolution.\n\n**Investigated:** The primary Claude session explored two architectural options for semantic shortcuts: Option A keeps them as simple search endpoints returning lists of observations filtered by concept type, while Option B transforms them into timeline-generating endpoints that return anchor observations with surrounding temporal context.\n\n**Next Steps:** Awaiting user decision on whether to keep semantic shortcuts as simple search endpoints (Option A) or enhance them to return timeline context (Option B), which will determine the implementation approach for the semantic shortcut API architecture.\n\n**Notes:** This represents a key architectural fork in the memory system design: balancing simplicity of search shortcuts against the richer context provided by timelines. The decision will impact how users interact with concept-filtered observations and whether they get isolated results or chronological narratives.\n\n---\nDate: 11/17/2025\n\n---\n\n## Clarify exposed search endpoints and investigate unified search parameters\n*Source: claude-mem://session/b1a1c481-6560-41bf-a0d3-23e448584f08*\n\n**Completed:** Identified the gap between current unified search capabilities and the catch-all parameters needed to fully replace granular search endpoints. Clarified that the 6 desired public-facing endpoints are: /api/search, /api/timeline, /api/decisions, /api/changes, /api/how-it-works, and /api/contextualize.\n\n**Learned:** The unified /api/search tool currently supports query, format, project, dateRange, limit, offset, and orderBy parameters, but lacks catch-all filtering parameters like type (document type filter), concept (observation concept tags), file (file path filter), and obs_type (observation type filter). The search implementation uses hybrid ChromaDB semantic search with SQLite FTS5 fallback, searches across all document types simultaneously, filters to a 90-day recency window, and defaults to 'index' format for token efficiency. The user wants only 6 specific search endpoints exposed publicly despite the potential for broader parameter combinations.\n\n**Investigated:** The unified search tool definition in src/servers/search-server.ts was examined to understand its current parameter structure and hybrid search implementation. The search tool's inputSchema was reviewed to identify which filtering parameters are currently available.\n\n**Next Steps:** The session is awaiting user decision on whether to add the missing catch-all parameters (type, concept, file, obs_type) to the unified search MCP tool to enable full replacement of granular endpoints while maintaining backward compatibility.\n\n**Notes:** The discovery revealed that while the unified search has sophisticated hybrid semantic search capabilities, it still needs additional filtering parameters to fully consolidate all search functionality into the 6 intended public endpoints. The granular endpoints would remain for backward compatibility but not be documented for end users.\n\n---\nDate: 11/17/2025\n\n---\n\n## Confirming REST-style endpoint design approach for search API implementation\n*Source: claude-mem://session/b1a1c481-6560-41bf-a0d3-23e448584f08*\n\n**Completed:** The architectural decision to use REST-style endpoints for the search API has been confirmed and approved. Comments describing these endpoints as \"Granular search endpoints\" were added to the codebase to clarify their purpose.\n\n**Learned:** REST-style endpoints are appropriate for the search API implementation. The system can support both unified search endpoints and resource-specific endpoints without conflicts. Resource-specific endpoints like /api/search/observations, /api/search/sessions, /api/search/prompts, /api/search/by-concept, and /api/search/by-file follow standard REST patterns where different resources have different endpoints. These endpoints are not deprecated or legacy - they represent clean REST design for accessing specific resource types.\n\n**Investigated:** The architectural pattern for search API endpoints was reviewed, examining whether REST-style resource-specific endpoints would cause confusion with existing endpoints in the system.\n\n**Next Steps:** Potentially refining the comment wording from \"Granular search endpoints (specific operations)\" to something like \"Resource-specific search endpoints\" for better clarity, pending user preference.\n\n**Notes:** The dual pattern approach allows flexibility: unified search endpoints can be used when mixing all result types is desired, while resource-specific endpoints serve use cases where the exact resource type is known upfront. This is standard REST architecture and represents a sound API design decision.\n\n---\nDate: 11/17/2025\n\n---\n\n## Clarifying whether granular search endpoints are deprecated given the unified search endpoint has parameters\n*Source: claude-mem://session/b1a1c481-6560-41bf-a0d3-23e448584f08*\n\n**Completed:** No code changes have been made. The discussion clarified that the granular endpoints are not actually deprecated in the current implementation because they provide type-specific filtering that the unified endpoint lacks.\n\n**Learned:** The unified search endpoint accepts parameters like query, format, project, dateRange, limit, offset, and orderBy, but does NOT have a type filter parameter. It returns mixed results from all document types (observations, sessions, prompts). The granular endpoints (/api/search/observations, /api/search/sessions, /api/search/prompts) serve a complementary purpose by returning only specific document types. The search uses hybrid ChromaDB semantic search with SQLite FTS5 fallback, and implements an index/full format pattern to optimize token usage.\n\n**Investigated:** The search-server.ts file was examined to understand the unified search tool implementation and its parameters, specifically looking at whether the search parameters make the granular type-specific endpoints redundant\n\n**Next Steps:** Awaiting user decision on whether to add a type parameter to the unified search endpoint, which would make it truly replace the granular endpoints and allow them to be deprecated as backward-compatible legacy endpoints\n\n**Notes:** This represents a potential architecture decision point: whether to consolidate all search functionality into a single parameterized endpoint (DRY principle) versus maintaining separate endpoints for different document types (explicit API design). The current hybrid approach exists because the type filter was never added to the unified search.\n\n---\nDate: 11/17/2025"}]